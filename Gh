import pandas as pd
from rapidfuzz.distance import Levenshtein

# â”€â”€â”€â”€â”€ Sample: Two DataFrames â”€â”€â”€â”€â”€
llm_df = pd.DataFrame({
    "LLM_output": [
        "The Eiffel Tower is located in Paris.",
        "Python is a programming language.",
        "Climate change is caused by greenhouse gases."
    ]
})

final_df = pd.DataFrame({
    "final_output": [
        "The Eiffel Tower is in Paris.",
        "Python is a versatile programming language.",
        "Greenhouse gases contribute to climate change."
    ]
})

# â”€â”€â”€â”€â”€ Compute Best Match & Similarity â”€â”€â”€â”€â”€

def compute_similarity(s1, s2):
    distance = Levenshtein.distance(s1, s2)
    max_len = max(len(s1), len(s2))
    return 1 - (distance / max_len) if max_len > 0 else 0

def find_best_llm_match(final_text, llm_outputs):
    best_score = -1
    best_match = None
    for llm_text in llm_outputs:
        score = compute_similarity(final_text, llm_text)
        if score > best_score:
            best_score = score
            best_match = llm_text
    return best_match, round(best_score, 4)

# Apply matching across final_df
matched_outputs = final_df['final_output'].apply(
    lambda x: find_best_llm_match(x, llm_df['LLM_output'])
)

# Split into separate columns
final_df[['matched_LLM_output', 'similarity_score']] = pd.DataFrame(matched_outputs.tolist(), index=final_df.index)

# Average model reliance:
model_reliance = final_df['similarity_score'].mean()

# â”€â”€â”€â”€â”€ Results â”€â”€â”€â”€â”€
print("ğŸ” Matched Output:")
print(final_df[['final_output', 'matched_LLM_output', 'similarity_score']])
print(f"\nğŸ“Š Average Model Reliance Score: {model_reliance:.4f}")
